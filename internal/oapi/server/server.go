// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// Defines values for BackupStatus.
const (
	BackupStatusCompleted BackupStatus = "completed"
	BackupStatusError     BackupStatus = "error"
	BackupStatusPending   BackupStatus = "pending"
)

// Defines values for StopModes.
const (
	All      StopModes = "all"
	Attached StopModes = "attached"
	Labelled StopModes = "labelled"
	Linked   StopModes = "linked"
	Writers  StopModes = "writers"
)

// Backup defines model for Backup.
type Backup struct {
	Created time.Time    `json:"created"`
	Id      string       `json:"id"`
	Status  BackupStatus `json:"status"`
}

// BackupStatus defines model for Backup.Status.
type BackupStatus string

// Error defines model for Error.
type Error struct {
	Error string `json:"error"`
}

// Filters defines model for Filters.
type Filters struct {
	ExcludeNames   []string `json:"exclude_names"`
	ExcludeVolumes []string `json:"exclude_volumes"`
	IncludeNames   []string `json:"include_names"`
	IncludeVolumes []string `json:"include_volumes"`
}

// StopModes defines model for StopModes.
type StopModes string

// Task defines model for Task.
type Task struct {
	Filters     Filters     `json:"filters"`
	LabelPrefix string      `json:"label_prefix"`
	StopModes   []StopModes `json:"stop_modes"`
}

// TriggerBackup defines model for TriggerBackup.
type TriggerBackup struct {
	Id    *string `json:"id,omitempty"`
	union json.RawMessage
}

// TriggerRestore defines model for TriggerRestore.
type TriggerRestore struct {
	Id    *int `json:"id,omitempty"`
	union json.RawMessage
}

// Version defines model for Version.
type Version struct {
	Created time.Time `json:"created"`
	Version string    `json:"version"`
}

// NotFound defines model for NotFound.
type NotFound = Error

// CreateBackup defines model for CreateBackup.
type CreateBackup = TriggerBackup

// RestoreBackup defines model for RestoreBackup.
type RestoreBackup = TriggerRestore

// TriggerBackupJSONRequestBody defines body for TriggerBackup for application/json ContentType.
type TriggerBackupJSONRequestBody = TriggerBackup

// TriggerRestoreJSONRequestBody defines body for TriggerRestore for application/json ContentType.
type TriggerRestoreJSONRequestBody = TriggerRestore

// AsTask returns the union data inside the TriggerBackup as a Task
func (t TriggerBackup) AsTask() (Task, error) {
	var body Task
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTask overwrites any union data inside the TriggerBackup as the provided Task
func (t *TriggerBackup) FromTask(v Task) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTask performs a merge with any union data inside the TriggerBackup, using the provided Task
func (t *TriggerBackup) MergeTask(v Task) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TriggerBackup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *TriggerBackup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	return err
}

// AsTask returns the union data inside the TriggerRestore as a Task
func (t TriggerRestore) AsTask() (Task, error) {
	var body Task
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTask overwrites any union data inside the TriggerRestore as the provided Task
func (t *TriggerRestore) FromTask(v Task) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTask performs a merge with any union data inside the TriggerRestore, using the provided Task
func (t *TriggerRestore) MergeTask(v Task) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TriggerRestore) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *TriggerRestore) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /backups)
	ListBackups(c *gin.Context)
	// Creates new backup
	// (POST /backups)
	TriggerBackup(c *gin.Context)
	// Deletes backup
	// (DELETE /backups/{id})
	DeleteBackup(c *gin.Context, id string)
	// Gets backup by id
	// (GET /backups/{id})
	GetBackup(c *gin.Context, id string)

	// (PUT /backups/{id})
	TriggerBackupWithId(c *gin.Context, id string)

	// (POST /backups/{id}/restore)
	TriggerRestore(c *gin.Context, id string)
	// Retrieves application version
	// (GET /version)
	GetVersion(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListBackups operation middleware
func (siw *ServerInterfaceWrapper) ListBackups(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListBackups(c)
}

// TriggerBackup operation middleware
func (siw *ServerInterfaceWrapper) TriggerBackup(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.TriggerBackup(c)
}

// DeleteBackup operation middleware
func (siw *ServerInterfaceWrapper) DeleteBackup(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteBackup(c, id)
}

// GetBackup operation middleware
func (siw *ServerInterfaceWrapper) GetBackup(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetBackup(c, id)
}

// TriggerBackupWithId operation middleware
func (siw *ServerInterfaceWrapper) TriggerBackupWithId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.TriggerBackupWithId(c, id)
}

// TriggerRestore operation middleware
func (siw *ServerInterfaceWrapper) TriggerRestore(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.TriggerRestore(c, id)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/backups", wrapper.ListBackups)
	router.POST(options.BaseURL+"/backups", wrapper.TriggerBackup)
	router.DELETE(options.BaseURL+"/backups/:id", wrapper.DeleteBackup)
	router.GET(options.BaseURL+"/backups/:id", wrapper.GetBackup)
	router.PUT(options.BaseURL+"/backups/:id", wrapper.TriggerBackupWithId)
	router.POST(options.BaseURL+"/backups/:id/restore", wrapper.TriggerRestore)
	router.GET(options.BaseURL+"/version", wrapper.GetVersion)
}

type BackupJSONResponse Backup

type NotFoundJSONResponse Error

type ListBackupsRequestObject struct {
}

type ListBackupsResponseObject interface {
	VisitListBackupsResponse(w http.ResponseWriter) error
}

type TriggerBackupRequestObject struct {
	Body *TriggerBackupJSONRequestBody
}

type TriggerBackupResponseObject interface {
	VisitTriggerBackupResponse(w http.ResponseWriter) error
}

type TriggerBackup200JSONResponse struct{ BackupJSONResponse }

func (response TriggerBackup200JSONResponse) VisitTriggerBackupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBackupRequestObject struct {
	Id string `json:"id"`
}

type DeleteBackupResponseObject interface {
	VisitDeleteBackupResponse(w http.ResponseWriter) error
}

type DeleteBackup200Response struct {
}

func (response DeleteBackup200Response) VisitDeleteBackupResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetBackupRequestObject struct {
	Id string `json:"id"`
}

type GetBackupResponseObject interface {
	VisitGetBackupResponse(w http.ResponseWriter) error
}

type GetBackup200JSONResponse struct{ BackupJSONResponse }

func (response GetBackup200JSONResponse) VisitGetBackupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetBackup404JSONResponse struct{ NotFoundJSONResponse }

func (response GetBackup404JSONResponse) VisitGetBackupResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type TriggerBackupWithIdRequestObject struct {
	Id string `json:"id"`
}

type TriggerBackupWithIdResponseObject interface {
	VisitTriggerBackupWithIdResponse(w http.ResponseWriter) error
}

type TriggerBackupWithId200JSONResponse Backup

func (response TriggerBackupWithId200JSONResponse) VisitTriggerBackupWithIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type TriggerRestoreRequestObject struct {
	Id   string `json:"id"`
	Body *TriggerRestoreJSONRequestBody
}

type TriggerRestoreResponseObject interface {
	VisitTriggerRestoreResponse(w http.ResponseWriter) error
}

type TriggerRestore200Response struct {
}

func (response TriggerRestore200Response) VisitTriggerRestoreResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetVersionRequestObject struct {
}

type GetVersionResponseObject interface {
	VisitGetVersionResponse(w http.ResponseWriter) error
}

type GetVersion200JSONResponse Version

func (response GetVersion200JSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {

	// (GET /backups)
	ListBackups(ctx context.Context, request ListBackupsRequestObject) (ListBackupsResponseObject, error)
	// Creates new backup
	// (POST /backups)
	TriggerBackup(ctx context.Context, request TriggerBackupRequestObject) (TriggerBackupResponseObject, error)
	// Deletes backup
	// (DELETE /backups/{id})
	DeleteBackup(ctx context.Context, request DeleteBackupRequestObject) (DeleteBackupResponseObject, error)
	// Gets backup by id
	// (GET /backups/{id})
	GetBackup(ctx context.Context, request GetBackupRequestObject) (GetBackupResponseObject, error)

	// (PUT /backups/{id})
	TriggerBackupWithId(ctx context.Context, request TriggerBackupWithIdRequestObject) (TriggerBackupWithIdResponseObject, error)

	// (POST /backups/{id}/restore)
	TriggerRestore(ctx context.Context, request TriggerRestoreRequestObject) (TriggerRestoreResponseObject, error)
	// Retrieves application version
	// (GET /version)
	GetVersion(ctx context.Context, request GetVersionRequestObject) (GetVersionResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// ListBackups operation middleware
func (sh *strictHandler) ListBackups(ctx *gin.Context) {
	var request ListBackupsRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListBackups(ctx, request.(ListBackupsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBackups")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListBackupsResponseObject); ok {
		if err := validResponse.VisitListBackupsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// TriggerBackup operation middleware
func (sh *strictHandler) TriggerBackup(ctx *gin.Context) {
	var request TriggerBackupRequestObject

	var body TriggerBackupJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.TriggerBackup(ctx, request.(TriggerBackupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TriggerBackup")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(TriggerBackupResponseObject); ok {
		if err := validResponse.VisitTriggerBackupResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBackup operation middleware
func (sh *strictHandler) DeleteBackup(ctx *gin.Context, id string) {
	var request DeleteBackupRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBackup(ctx, request.(DeleteBackupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBackup")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteBackupResponseObject); ok {
		if err := validResponse.VisitDeleteBackupResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetBackup operation middleware
func (sh *strictHandler) GetBackup(ctx *gin.Context, id string) {
	var request GetBackupRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetBackup(ctx, request.(GetBackupRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBackup")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetBackupResponseObject); ok {
		if err := validResponse.VisitGetBackupResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// TriggerBackupWithId operation middleware
func (sh *strictHandler) TriggerBackupWithId(ctx *gin.Context, id string) {
	var request TriggerBackupWithIdRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.TriggerBackupWithId(ctx, request.(TriggerBackupWithIdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TriggerBackupWithId")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(TriggerBackupWithIdResponseObject); ok {
		if err := validResponse.VisitTriggerBackupWithIdResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// TriggerRestore operation middleware
func (sh *strictHandler) TriggerRestore(ctx *gin.Context, id string) {
	var request TriggerRestoreRequestObject

	request.Id = id

	var body TriggerRestoreJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.TriggerRestore(ctx, request.(TriggerRestoreRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TriggerRestore")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(TriggerRestoreResponseObject); ok {
		if err := validResponse.VisitTriggerRestoreResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVersion operation middleware
func (sh *strictHandler) GetVersion(ctx *gin.Context) {
	var request GetVersionRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVersion(ctx, request.(GetVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetVersionResponseObject); ok {
		if err := validResponse.VisitGetVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/7xXS4/bNhD+K8K0RzYS2hwK3bJtEizQF9IgPRjGgpbGNrMUyZKjTQxD/70gJVqmJdvB",
	"PnqzR+I333zzovZQ6cZohYoclHuw+G+Ljm50LTAYfrHICW94dd8a/7/SilCR/8mNkaLiJLTKPzutvM1V",
	"W2y4//W9xTWU8F0+Osj7py7/aMVmg3ZA7bqOQY2ussJ4MCihf5KRzlaYVYFCDSywExZrKMm22DH4gI60",
	"fSF6A/jj+XXe4oxWrtfymWmel+9NFp8x+EPTO92q+tncvrVW2zmvbxUJ2mVKU7YOHv0rw6k0fGO1QUtD",
	"iUX9yj2stW04QQk1J/yBRIPAgHYGoQRHVqiND0mEdydmR5zagIiqbaBcgEFV+4csVLnEPksYAlhOgLvj",
	"BC68FwZjbgf08ZhefcaKvONekUlcGM2X/ZzSGXHfCUlo3Qzy10q2Nd4p3vSGGte8lQTlYslAEDZuVqHB",
	"wK3lO/8/4jxo2T4NSajnYRRxnsroNJcJvakbdiLpVJq5/PxN2vyua0xqjksJDCRfoZShcL5YEbLIgBPx",
	"ahuMUqh7rGeKkMFH7u6nKV+PtXCpOWPJdAOFO2NxLb4mOsLK96Gd6yxH2tw1MaSD2Jc8jiJcS0JCKPHF",
	"DuHNyZxuCz+71O7PNZSLK1Pc69gt2YmQs8OjO+82boFn9SsU4QbtvONPaJ3oJ/ITB+XDiDRmv3hVvCrg",
	"2vSLR8cROE1NFxp2rXv8ZD+GCsve/HXrHQmSeDDCES2QnNCFoLVBxY2AEn4a+BlO2xB2vgqZD783GLaX",
	"VyXsrtsaSvhNOLoZ3klWrmqlZEB843xIPQwsOwZGuxmctNDY0WVod64LkvtSnlyWTrf/j0VxHmV4b9zp",
	"DFzbNNzuoBzuYC5T+CVbRXKTqDp2UCrfi7rrs+KX3jTSX4P9KNApzzShYaFH5ym7HstdYMbm0/Ye6SKD",
	"b1OKwevi9fXXD9eglPx7pMg8W+2ysPPn6oVb3mA/gBen2gzHw1nhDb5ygYFfJb7XpzdDdnTVOm1DPzja",
	"a8X5j6DtbX1Gtxe+XA7zIFv10+taGfocxAH6P8t4qcnjWH9El6cfHd23tM+gweFT4axyRxP7XM98Okzm",
	"F0t+dDH3aTGCZuNrxy31AckKfECXHRHIxn0S43Y7R9j4uP1xtA+xLForoYQtkSnzXOqKy612VP5cFEXY",
	"qwPAPlZGnErsYBmgu2X3XwAAAP//HJWrLOAOAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
